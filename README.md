# fetch-swarm

A no-dependency wrapper to global fetch that adds concurrency and significant performance gains. This library is tuned for hitting a server many times and is dead-simple to use.

<p align="center">
  <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/tests/mochawesome.html"><img alt="Test report" src="https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/tests.svg"></a>
  <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/coverage/index.html"><img alt="Coverage report" src="https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/coverage.svg"></a>
  <a href="https://standardjs.com"><img alt="JavaScript Style Guide" src="https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/style.svg"></a>
  <a href="https://nodejs.org/dist/latest-v18.x/docs/api/globals.html#fetch"><img alt="Node.js v18.x docs" src="https://raw.githubusercontent.com/ctheiss/fetch-swarm/main/build/node.svg"></a>
</p>

## Features

*   Request throttling
*   Automatic retry on failure
*   Lazy loading and minimal object caching to keep the memory footprint to a minimum
*   No implementation leaks, it just works as expected!

## Usage

Use **npm** to install: `npm install fetch-swarm`

```js
import { Connection } from 'fetch-swarm'

// Creates a session and thread pool; typically you create one connection for each server you're hitting.
const conn = Connection.create()

// Executes a single fetch
const loginResponse = await conn.one('http://cat-videos.net/login?user=fanatic&password=c4tl0v3r')

// Session information is maintained across fetches in the same connection,
// so subsequent fetches will still be logged-in.
const profileUrls = [
 'http://cat-videos.net/profile/mookie',
 'http://cat-videos.net/profile/kenneth',
 'http://cat-videos.net/profile/itchy']

// Asynchronously execute fetches for all profile pages.
// The order is not guaranteed, so you wait only until the first fetch is complete.
for await (const profileResponse of conn.swarm(profileUrls)) {
 // Asynchronously execute fetches for each friend link found on the profile pages.
 // These fetches take precedence over those in the outer loop to minimize overall waiting.
 // Order *does* matter now, so specify that in the options.  Obviously, there may be a small
 // performance hit if the second profile fetch is done but we're still waiting on the first.
 for await (const friendResponse of conn.swarm(profileResponse.friendUrls, { ordered: true })) {
   // Do something intelligent with the responses, like using
   // regex to parse the HTML (see http://stackoverflow.com/a/1732454)
   friendResponse.html.parse()
 }
}
```

# API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

### Table of Contents

*   [Connection](#connection)
    *   [swarm](#swarm)
        *   [Parameters](#parameters)
    *   [one](#one)
        *   [Parameters](#parameters-1)
    *   [create](#create)
        *   [Parameters](#parameters-2)
*   [Result](#result)
    *   [Properties](#properties)

## Connection

Typically you create one connection for each server you're hitting. This object maintains session information, connection pools, fetch priorities, etc.

### swarm

Execute each request asynchronously.

Subsequent calls to swarm() or one() on the same Connection will be prioritized over earlier calls. This is generally aligned with how fetches are processed (one fetch is inspected, which leads to more fetches whose responses are inspectedâ€¦ etc.)

This function will try hard to finish all fetches, use stop to cancel any pending fetches and/or kill executing fetches.

#### Parameters

*   `requests` **iterable**&#x20;
*   `options` **[Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)**&#x20;

    *   `options.ordered` **[boolean](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Boolean)** Whether the responses are guaranteed to be in the same order as the requests (optional, default `false`)

### one

#### Parameters

*   `request` &#x20;

Returns **[Result](#result)**&#x20;

### create

Create a new connection.

#### Parameters

*   `options` **[Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)**&#x20;

    *   `options.concurrency` **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** The maximum number of concurrent fetches (optional, default `2`)
    *   `options.minMsBetweenRequests` **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** Every fetch is guaranteed to be separated by at least this many milliseconds (counting from start to start) (optional, default `150`)
    *   `options.timeoutMs` **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** Stop and fail a fetch if it has not completed after this many milliseconds; timed-out fetched may be retried depending on the other options (0 means no timeout) (optional, default `0`)
    *   `options.retry` **[number](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number)** Retry failed fetches this many times before throwing an error; note that (per spec) HTTP failures such as 4xx or 5xx *do not* count as failed fetches (optional, default `0`)

Returns **[Connection](#connection)**&#x20;

## Result

Type: [Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)

### Properties

*   `request` **[Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** the object given to fetch (feel free to attach your own data here to make it easier to map on response)
*   `response` **[Object](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object)** the object responded by fetch
